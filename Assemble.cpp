#include "Assemble.h"
#include<iostream>


/*//Συνθέτει τον πίνακα A και f στο σύστημα A*x=f για την επίλυση του x.

// Output, double ADIAG(NU), οι «διαγώνιοι» συντελεστές.Δηλαδή,
// ADIAG(I) είναι ο συντελεστής του Ι-οστού αγνώστου στην Ι-οστή εξίσωση.
//
// Output, double ALEFT(NU), οι «αριστεροί» συντελεστές. Δηλ, 
// ALEFT(I) είναι ο συντελεστής του (I-1)-οστού αγνώστου στην I-οστή εξίσωση.
// Δεν υπάρχει τιμή στο ALEFT(1), δεδομένου ότι η πρώτη εξίσωση
// δεν αναφέρεται σε έναν «0-οστό» άγνωστο.
//
// Output, double ARITE(NU).
// ARITE(I) είναι ο «δεξιός» συντελεστής της I-οστής
// εξίσωση του γραμμικού συστήματος. ARITE(I) είναι ο συντελεστής
// του (I+1)-οστού αγνώστου στην I-οστή εξίσωση. Υπάρχει
// δεν υπάρχει τιμή στο ARITE(NU) επειδή η NU-οστή εξίσωση δεν
// αναφέρεται σε έναν «NU+1»-οστό άγνωστο.
//
// Output, double F(NU).
// ASSEMBLE αποθηκεύει στην F τη δεξιά πλευρά τωμ γραμμικών
// εξισώσεων.
// SOLVE αντικαθιστά αυτές τις τιμές του F με τη λύση των
// γραμμικών εξισώσεων.
//
// Input, double H(NSUB) 
// H(I) είναι το μήκος του υποδιαστήματος I. Αυτός ο κώδικας χρησιμοποιεί 
// ίση απόσταση για όλα τα υποδιαστήματα. 

// Input, int INDX[NSUB+1]. 
// Για έναν κόμβο I, INDX(I) είναι ο δείκτης του άγνωστου 
// που σχετίζεται με τον κόμβο Ι. 
// Αν το INDX(I) είναι ίσο με -1, τότε δεν συνδέεται κανένας άγνωστος. 
// με αυτόν τον κόμβο, επειδή μια οριακή συνθήκη που καθορίζει τη
// τιμή του U έχει εφαρμοστεί στον κόμβο. 
// Οι άγνωστοι αριθμούνται αρχίζοντας από το 1. 
// Αν το IBC είναι 2 ή 4, τότε υπάρχει μια άγνωστη τιμή του U 
// στον κόμβο 0, η οποία θα είναι ο άγνωστος αριθμός 1.  Αλλιώς, 
// Ο άγνωστος αριθμός 1 θα συσχετιστεί με τον κόμβο 1. 
// Αν το IBC είναι 1 ή 4, τότε υπάρχει μια άγνωστη τιμή του U 
// στον κόμβο NSUB, η οποία θα είναι ο άγνωστος NSUB ή NSUB+1, 
// ανάλογα με το αν υπήρχε άγνωστος στον κόμβο 0. 

// Input, int NL. 
// Το πλήθος των συναρτήσεων βάσης που χρησιμοποιούνται σε μια ενιαία 
// υποδιάστημα.  (NL-1) είναι ο βαθμός των πολυωνύμων. 
// που χρησιμοποιούνται.  Για αυτόν τον κώδικα, ο NL είναι σταθερός στο 2, που σημαίνει ότι 
// χρησιμοποιούνται ως βάση γραμμικές συναρτήσεις κατά βάση.

// Input, int NODE[NL*NSUB]. 
// Για κάθε υποδιάστημα I: 
// NODE[0+I*2] είναι ο αριθμός του αριστερού κόμβου, και 
// ΝΟDE[1+I*2] είναι ο αριθμός του δεξιού κόμβου. 

 // NU είναι ο αριθμός των αγνώστων του γραμμικού συστήματος. 
// Ανάλογα με την τιμή του IBC, θα υπάρχει NSUB-1, 
// NSUB, ή NSUB+1 άγνωστες τιμές, οι οποίες είναι οι συντελεστές 
// των συναρτήσεων βάσης. 

// Input, int NQUAD. 
// Το πλήθος των σημείων τετραγωνισμού που χρησιμοποιούνται σε ένα υποδιάστημα. 
// Αυτός ο κώδικας χρησιμοποιεί NQUAD = 1. 

// Input, int NSUB. 
// Ο αριθμός των υποδιαστημάτων στα οποία χωρίζεται το διάστημα [XL,XR]. 

// Input, double UL. 
// Εάν το IBC είναι 1 ή 3, το UL είναι η τιμή που απαιτείται U 
// να έχει στο σημείο X = XL. 
// Αν το IBC είναι 2 ή 4, UL είναι η τιμή που πρέπει να έχει η U'. 
// να έχει στο X = XL. 

// Input, double UR. 
// Αν το IBC είναι 2 ή 3, UR είναι η τιμή που πρέπει να έχει το U 
// να έχει στη θέση X = XR. 
// Αν το IBC είναι 1 ή 4, UR είναι η τιμή που πρέπει να έχει η U'. 
// να έχει στη θέση X = XR. 

// Input, double XL. 
// XL είναι το αριστερό ακραίο σημείο του διαστήματος στο οποίο η 
// επιλύεται η διαφορική εξίσωση. 


// XR είναι το δεξιό ακραίο σημείο του διαστήματος στο οποίο η 
// επιλύεται η διαφορική εξίσωση. 
*/
Assemble::Assemble() {};

void Assemble::assemble(double f[], double arite[], double aleft[], double adiag[],
    double h[], int indx[], const int nl, int node[], const int nu,
    const double ul, const double ur, double part[], double xquad[], const int nQuad, const int nsub)
{
     
    //Αρχικοποίηση
    for (int i = 0; i < nu; i++)
    {
        f[i] = 0.0;
        adiag[i] = 0.0;
        aleft[i] = 0.0;
        arite[i] = 0.0;

    }//for    
    
    for (int i = 0; i < nsub; i++)
    {
        he = h[i];                          // Μήκος υποδιστήματος.
        xl = part[node[0 + i * 2]];         // Υπεύθυνο για τον αριστερό σημείο που επιλύεται η διαφορική εξίσωση
        xr = part[node[1 + i * 2]];         // Υπεύθυνο για το δεξί σημείο που επιλύεται η διαφορική εξίσωση
       
        for (int k  = 0; k < nQuad; k++)
        {
            xquade = xquad[i];      // Τετραγωνικά σημεία. (Το μισό του κάθε υποδιαστήματος)
          
          //  υπολογίζουμε τα ολοκληρώματα που σχετίζονται με τις συναρτήσεις βάσης,
          //  για τους αριστερούς και δεξιούς κόμβους.
          //

            for (int j = 1; j <= nl; j++)       //nl=2 // 2 epanalhpseis gia j=1 kai j=2
            {
                ig = node[j - 1 + i * 2];       //i=0 (node[0] = 0, node[1]=1 )  // i=1 (node[2],node[3])  // i=2 (node[4],node[5]) ...
                iu = indx[ig] - 1;              //i=0 (iu = -1, iu = 0) ...
               
                if (iu >= 0)
                {
                    phi.phi(j, xquade, &phii, &phiix, xl, xr);                      // Υπολογισμός των συναρτήσεων Βάσης.

                    f[iu] = f[iu] + he * functions.setFf(xquade) * phii;            // Υπολογισμός δεξιού μέλους f στα τετραγωνικά σημεία.
                    
                    //  Υπολογισμός των οριακών κόμβων στους οποίους ορίζεται η U'.
                    //

                    if (ig == 0)
                    {
                        x = 0.0;
                        f[iu] = f[iu] - functions.setPp(x) * ul;                    // Υπολογισμός των άκρων 
                        
                    }//if2

                    else if (ig == nsub)
                    {
                        x = 1.0;
                        f[iu] = f[iu] + functions.setPp(x) * ur;                    // Υπολογισμός των άκρων 
                       
                    }//else if
                    
                    //
                    //  Υπολογισμός των ολοκληρωμάτων που παίρνουν ένα γινόμενο της
                    //  συνάρτησης βάσης επί την ίδια ή πολλαπλασιάζει την άλλη συνάρτηση βάσης
                    //  που είναι μη μηδενική σε αυτό το διάστημα.
                    //
                    for (int k = 1; k <= nl; k++)           //nl=2 // 2 epanalhpseis gia k=1 kai k=2
                    {
                        jg = node[k - 1 + i * 2];           //j=1 node[0], node[1]  //j=2 node[0], node[1]...
                        ju = indx[jg] - 1;                  //j=1 (indx[node[0]]-1, indx[node[1]]-1)   //j=2 (indx[node[0]]-1, indx[node[1]]-1)...
                      
                        phi.phi(k, xquade, &phij, &phijx, xl, xr);

                        aij = he * (functions.setPp(xquade) * phiix * phijx + functions.setQq(xquade) * phii * phij);
                        
                        //  Εάν δεν υπάρχει μεταβλητή που να σχετίζεται με τον κόμβο, τότε είναι
                        //  μία καθορισμένη οριακή τιμή, οπότε πολλαπλασιάζουμε τον συντελεστή επί 
                        //  την καθορισμένη οριακή τιμή και τον αφαιρούμε απο τη δεξιά πλευρά. 
                        //

                        if (ju < 0)
                        {
                            if (jg == 0)
                            {
                                f[iu] = f[iu] - aij * ul;
                            }//if2

                            else if (jg == nsub)
                            {
                                f[iu] = f[iu] - aij * ur;
                            }//else if
                            
                        }//if1
                            
                        //  Ειδάλλως, προσθέτουμε τον συντελεστή που μόλις υπολογίσαμε στη
                        //  διαγώνιο ή την αριστερή ή τη δεξιά καταχώρηση της γραμμής IU του πίνακα.
                        //

                        else
                        {
                            if (iu == ju)
                            {
                                adiag[iu] = adiag[iu] + aij;
                                
                            }//if2

                            else if (ju < iu)
                            {
                                aleft[iu] = aleft[iu] + aij;
                                
                            }//else if

                            else
                            {
                                arite[iu] = arite[iu] + aij;
                                
                            }//else2

                        }//else1


                    }//for4


                }//if1


            }//for3

        }//for2

    }//for1
    
}


